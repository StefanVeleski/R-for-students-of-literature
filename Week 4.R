#### For loops####

# The main purpose of programming has always been automation. For example, if we'd like to print 31 statements like the ones below, for each day of March, copy pasting this expression while changing the date at each step would quickly become tedious.

print(paste("It's March", 1))
print(paste("It's March", 2))
print(paste("It's March", 3))

# As soon as we copy paste more than twice, it is time to automate the process.

# One of the most common ways of doing this, which is common for other programming languages as well, is with the help of a for loop. 

for(i in 1:31){
  print(paste("It's March", i))
}

# In this case, i is a value indicating each element of the sequence (i is the standard placeholder, but we can change it to day for example) 

# The previous example was a for loop that iterated over an integer vector. For loops can also iterate over more complicated data structures. Let's try to use a for loop to fill out the values of a matrix. 

# For loops which have more than one level are called nested for loops

# First of all we need to make an empty matrix which we will later fill in with the for loop. 
res <-  matrix(nrow=4, ncol=4) 

for(i in 1:nrow(res))  # Assigned a variable  ‘i’ for each row
{
  for(j in 1:ncol(res)) # Assigned a variable  ‘j' for each column
  {
    res[i,j] = i*j         # calculating the product of two indices
  }
}
print(res)

# Don't get carried away with for loops - it may look like fun, but nesting more than twice can create practically unreadable code. 

# It is considered good practice to use for loops in creating programs, while the apply function is preferred when doing hands on data analysis.
# For loops are difficult to follow, so if you'd like to do something behind the scenes so to speak, go ahead, but for data analysis you would ideally want your code to be as reproducible as possible. That's why the apply family of functions would work better there, which reduce much of the clutter generated by the for loop family of functions. 

#### lapply and sapply####

# We can start off with the lapply and sapply functions. For the analyses below we will use the mtcars dataset which comes built in in base R. You can load these datasets in the global environment with the data() function.
data(mtcars)

# Let's first run the str() function on the full dataset to see what we're working with here. 
str(mtcars)

# You will see that all of the columns of the mtcars data frame are numeric vectors. However, if we open the documentation for the mtcars dataset, we will see that the 8th and 9th column (indicating the shape of the engine, and the type of transmission) would work better as factors. 
?mtcars

# This overwrites these two columns/numberic vectors with factor vectors. 
mtcars$vs <- as.factor(mtcars$vs)
mtcars$am <- as.factor(mtcars$am)

# We can doublecheck that with the str () function. 
str(mtcars)

# Instead of running the str () function, we can also check the class of each of the columns of mtcars with the apply family of functions. Let's make an object (in this case a list), that will store the class of each of the columns of mtcars.
class_l <- lapply(mtcars, class)

# We now have a list containing eleven character vectors of length one, that store the class of the columns as text. Obviously, in this case, we don't even need a list because its elements are all of the same class. That's why we should use sapply instead. 

# What sapply does is basically run lapply(), but then try to simplify the results. 
# The following expression stores the column classes in a character vector
class_v <- sapply(mtcars, class)
class(class_v)

# sapply() returns a vector if the result is a list where every element is of length one. If the result is a list where every element is a vector of the same length (> 1), sapply() returns a matrix. If sapply() can't figure things out, then it just returns a list, no different from what lapply() would give you.

# Now let's try to find the average of each column (except from columns 8 and 9) which are factor vectors

# If you remember from last session, if we want exclude certain values we use the minus operator when subsetting
values_cars <- mtcars[,c(-8,-9)]

# This expression provides a list where each index position is filled with a single value
lapply(values_cars, mean)

# This expression will convert this to a vector
means_mtcars <- sapply(values_cars, mean)
means_mtcars

#### vapply and tapply####

# These are the two other most important functions of the apply family.
# vapply () is a safer alternative to sapply that lets you specify the class of the output. 
# Whereas sapply() tries to 'guess' the correct format of the result, vapply() allows you to specify it explicitly. If the result doesn't match the format you specify, vapply() will throw an error, causing the operation to stop. This can prevent significant problems in your code that might be caused by getting unexpected return values from sapply().
vapply(mtcars, class, character(1))

# tapply () splits the data into groups based on some variable and then applies a function to each of these groups. In other words tapply() computes a measure (mean, median, min, max, etc..) or a function for each factor variable in a vector. It is a very useful function that lets you create subsets of a vector and then apply some functions to each subset.

tapply(mtcars$mpg, mtcars$am, mean)

# Try to do the same with the number of cylinders, but you would first need to convert the cyl column into a factor.

#### Package of the week#### 

# DataEditR

# Instaling the package
install.packages("DataEditR")
library(DataEditR)

# This function opens up the DataEditR panel
data_edit(USArrests)

# Most of the data manipulation and data entry functionality of the package can be accessed through the DataEditR panel itself, instead of the command line. 
# This will be shown in detail in the Youtube video. 
